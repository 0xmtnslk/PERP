#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Geli≈ümi≈ü Telegram Bot - Kripto Ticaret Y√∂netim Sistemi
Kullanƒ±cƒ± kaydƒ±, API y√∂netimi, ticaret ayarlarƒ± ve canlƒ± bildirimler
"""
import os
import json
import sqlite3
import asyncio
import logging
import time
from datetime import datetime
from typing import Dict, Optional, List
import subprocess
import base64
from cryptography.fernet import Fernet
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
from notification_config import notification_config

# Telegram imports (baƒüƒ±mlƒ±lƒ±k kontrol√º)
try:
    from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup, ReplyKeyboardMarkup, KeyboardButton
    from telegram.ext import Application, CommandHandler, MessageHandler, CallbackQueryHandler, ContextTypes, filters
    from telegram.constants import ParseMode
except ImportError:
    print("‚ö†Ô∏è python-telegram-bot k√ºt√ºphanesi bulunamadƒ±!")
    print("Kurulum i√ßin: pip install python-telegram-bot")
    exit(1)

# Logging konfig√ºrasyonu
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s', 
    level=logging.INFO
)
logger = logging.getLogger(__name__)

class APIKeyEncryption:
    """API anahtarlarƒ±nƒ± g√ºvenle ≈üifrelemek i√ßin sƒ±nƒ±f"""
    
    def __init__(self, password: str = None):
        if password is None:
            # Sistem tabanlƒ± varsayƒ±lan parola (g√ºvenlik i√ßin env var kullanƒ±lmalƒ±)
            password = os.environ.get('ENCRYPTION_KEY', 'default_encryption_key_change_in_production')
        
        # Tuz i√ßin sabit deƒüer (√ºretimde random olmalƒ± ve kaydedilmeli)
        salt = b'stable_salt_value_'  # 16 byte
        
        # Key derivation
        kdf = PBKDF2HMAC(
            algorithm=hashes.SHA256(),
            length=32,
            salt=salt,
            iterations=100000,
        )
        key = base64.urlsafe_b64encode(kdf.derive(password.encode()))
        self.cipher_suite = Fernet(key)
    
    def encrypt(self, text: str) -> str:
        """Metni ≈üifrele"""
        if not text:
            return text
        return self.cipher_suite.encrypt(text.encode()).decode()
    
    def decrypt(self, encrypted_text: str) -> str:
        """≈ûifrelenmi≈ü metni √ß√∂z"""
        if not encrypted_text:
            return encrypted_text
        try:
            return self.cipher_suite.decrypt(encrypted_text.encode()).decode()
        except Exception as e:
            logger.error(f"Decryption error: {e}")
            return ""

class InputValidator:
    """Kullanƒ±cƒ± giri≈ülerini doƒürulayan g√ºvenlik sƒ±nƒ±fƒ±"""
    
    # G√ºvenlik limitleri
    MIN_TRADING_AMOUNT = 1.0
    MAX_TRADING_AMOUNT = 10000.0
    MIN_TAKE_PROFIT = 50.0  # %50
    MAX_TAKE_PROFIT = 2000.0  # %2000
    ALLOWED_TRADING_AMOUNTS = [10, 20, 50, 100, 200, 500, 1000]
    ALLOWED_TAKE_PROFITS = [200, 300, 500, 600, 800, 1000, 1500]
    
    @staticmethod
    def validate_trading_amount(amount: float, user_id: int = None) -> tuple[bool, str]:
        """Ticaret miktarƒ±nƒ± doƒürula"""
        try:
            amount = float(amount)
        except (ValueError, TypeError):
            logger.warning(f"Invalid trading amount input: {amount} from user {user_id}")
            return False, "Ge√ßersiz miktar formatƒ±. Sayƒ±sal deƒüer giriniz."
        
        if amount < InputValidator.MIN_TRADING_AMOUNT:
            logger.warning(f"Trading amount too low: {amount} from user {user_id}")
            return False, f"Minimum ticaret miktarƒ±: {InputValidator.MIN_TRADING_AMOUNT} USDT"
        
        if amount > InputValidator.MAX_TRADING_AMOUNT:
            logger.warning(f"Trading amount too high: {amount} from user {user_id}")
            return False, f"Maksimum ticaret miktarƒ±: {InputValidator.MAX_TRADING_AMOUNT} USDT"
        
        # Izin verilen deƒüerler kontrol√º
        if amount not in InputValidator.ALLOWED_TRADING_AMOUNTS:
            logger.warning(f"Unauthorized trading amount: {amount} from user {user_id}")
            return False, f"Izin verilen miktarlar: {', '.join(map(str, InputValidator.ALLOWED_TRADING_AMOUNTS))} USDT"
        
        logger.info(f"Valid trading amount validated: {amount} USDT for user {user_id}")
        return True, "Ge√ßerli"
    
    @staticmethod
    def validate_take_profit(percentage: float, user_id: int = None) -> tuple[bool, str]:
        """Take profit y√ºzdesini doƒürula"""
        try:
            percentage = float(percentage)
        except (ValueError, TypeError):
            logger.warning(f"Invalid take profit input: {percentage} from user {user_id}")
            return False, "Ge√ßersiz y√ºzde formatƒ±. Sayƒ±sal deƒüer giriniz."
        
        if percentage < InputValidator.MIN_TAKE_PROFIT:
            logger.warning(f"Take profit too low: {percentage}% from user {user_id}")
            return False, f"Minimum take profit: %{InputValidator.MIN_TAKE_PROFIT}"
        
        if percentage > InputValidator.MAX_TAKE_PROFIT:
            logger.warning(f"Take profit too high: {percentage}% from user {user_id}")
            return False, f"Maksimum take profit: %{InputValidator.MAX_TAKE_PROFIT}"
        
        # Izin verilen deƒüerler kontrol√º
        if percentage not in InputValidator.ALLOWED_TAKE_PROFITS:
            logger.warning(f"Unauthorized take profit: {percentage}% from user {user_id}")
            return False, f"Izin verilen y√ºzdelik: {', '.join(map(str, InputValidator.ALLOWED_TAKE_PROFITS))}%"
        
        logger.info(f"Valid take profit validated: {percentage}% for user {user_id}")
        return True, "Ge√ßerli"
    
    @staticmethod
    def sanitize_user_input(text: str) -> str:
        """Kullanƒ±cƒ± giri≈üini temizle"""
        if not text:
            return ""
        # Tehlikeli karakterleri temizle
        dangerous_chars = ['<', '>', '&', '"', "'", ';', '(', ')', '{', '}', '[', ']']
        for char in dangerous_chars:
            text = text.replace(char, '')
        return text.strip()[:200]  # Maksimum 200 karakter

class TradingBotDatabase:
    """Kullanƒ±cƒ± verilerini y√∂neten veritabanƒ± sƒ±nƒ±fƒ±"""
    
    def __init__(self, db_path="trading_bot.db"):
        self.db_path = db_path
        self.encryption = APIKeyEncryption()
        self.init_database()
    
    def init_database(self):
        """Veritabanƒ±nƒ± ba≈ülat ve tablolarƒ± olu≈ütur"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        # Kullanƒ±cƒ±lar tablosu
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS users (
                user_id INTEGER PRIMARY KEY,
                username TEXT,
                first_name TEXT,
                last_name TEXT,
                is_active BOOLEAN DEFAULT 1,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                last_activity TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        ''')
        
        # API anahtarlarƒ± tablosu (≈üifrelenmi≈ü)
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS user_api_keys (
                user_id INTEGER PRIMARY KEY,
                bitget_api_key TEXT,
                bitget_secret_key TEXT,
                bitget_passphrase TEXT,
                is_configured BOOLEAN DEFAULT 0,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users (user_id)
            )
        ''')
        
        # Ticaret ayarlarƒ± tablosu
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS user_settings (
                user_id INTEGER PRIMARY KEY,
                trading_amount_usdt REAL DEFAULT 20.0,
                take_profit_percentage REAL DEFAULT 500.0,
                auto_trading BOOLEAN DEFAULT 1,
                notifications BOOLEAN DEFAULT 1,
                emergency_stop BOOLEAN DEFAULT 0,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users (user_id)
            )
        ''')
        
        # ƒ∞≈ülem ge√ßmi≈üi tablosu
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS trade_history (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER,
                symbol TEXT,
                action TEXT,  -- 'BUY', 'SELL', 'EMERGENCY_STOP'
                amount_usdt REAL,
                price REAL,
                profit_loss REAL,
                status TEXT,  -- 'OPEN', 'CLOSED', 'CANCELLED'
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                closed_at TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users (user_id)
            )
        ''')
        
        # Bildirimler tablosu
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS notifications (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER,
                type TEXT,  -- 'NEW_COIN', 'TRADE_OPEN', 'TRADE_CLOSED', 'SYSTEM'
                title TEXT,
                message TEXT,
                is_read BOOLEAN DEFAULT 0,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users (user_id)
            )
        ''')
        
        conn.commit()
        conn.close()
        print("üóÑÔ∏è Veritabanƒ± ba≈üarƒ±yla ba≈ülatƒ±ldƒ±")
    
    def register_user(self, user_id: int, username: str, first_name: str, last_name: str = None):
        """Kullanƒ±cƒ±yƒ± kaydet"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
            INSERT OR REPLACE INTO users 
            (user_id, username, first_name, last_name, last_activity)
            VALUES (?, ?, ?, ?, CURRENT_TIMESTAMP)
        ''', (user_id, username, first_name, last_name))
        
        # Varsayƒ±lan ayarlarƒ± olu≈ütur
        cursor.execute('''
            INSERT OR IGNORE INTO user_settings (user_id) VALUES (?)
        ''', (user_id,))
        
        conn.commit()
        conn.close()
    
    def save_api_keys(self, user_id: int, api_key: str, secret_key: str, passphrase: str):
        """API anahtarlarƒ±nƒ± ≈üifreleyerek kaydet"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        # API anahtarlarƒ±nƒ± ≈üifrele
        encrypted_api_key = self.encryption.encrypt(api_key)
        encrypted_secret_key = self.encryption.encrypt(secret_key)
        encrypted_passphrase = self.encryption.encrypt(passphrase)
        
        cursor.execute('''
            INSERT OR REPLACE INTO user_api_keys 
            (user_id, bitget_api_key, bitget_secret_key, bitget_passphrase, is_configured)
            VALUES (?, ?, ?, ?, 1)
        ''', (user_id, encrypted_api_key, encrypted_secret_key, encrypted_passphrase))
        
        conn.commit()
        conn.close()
        logger.info(f"üîê API anahtarlarƒ± ≈üifrelenmi≈ü olarak kaydedildi: user_id={user_id}")
    
    def get_user_api_keys(self, user_id: int) -> Optional[Dict]:
        """Kullanƒ±cƒ±nƒ±n API anahtarlarƒ±nƒ± √ß√∂zerek getir"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
            SELECT bitget_api_key, bitget_secret_key, bitget_passphrase, is_configured
            FROM user_api_keys WHERE user_id = ?
        ''', (user_id,))
        
        result = cursor.fetchone()
        conn.close()
        
        if result:
            # ≈ûifrelenmi≈ü anahtarlarƒ± √ß√∂z
            try:
                api_key = self.encryption.decrypt(result[0]) if result[0] else ""
                secret_key = self.encryption.decrypt(result[1]) if result[1] else ""
                passphrase = self.encryption.decrypt(result[2]) if result[2] else ""
                
                return {
                    'api_key': api_key,
                    'secret_key': secret_key, 
                    'passphrase': passphrase,
                    'is_configured': bool(result[3])
                }
            except Exception as e:
                logger.error(f"API key decryption error for user {user_id}: {e}")
                return None
        return None
    
    def update_user_settings(self, user_id: int, **settings):
        """Kullanƒ±cƒ± ayarlarƒ±nƒ± g√ºvenlik doƒürulamasƒ± ile g√ºncelle"""
        # Giri≈ü doƒürulamasƒ±
        for key, value in settings.items():
            if key == 'trading_amount_usdt':
                is_valid, message = InputValidator.validate_trading_amount(value, user_id)
                if not is_valid:
                    logger.error(f"Invalid trading amount update attempt: {value} for user {user_id} - {message}")
                    raise ValueError(f"Ge√ßersiz ticaret miktarƒ±: {message}")
            elif key == 'take_profit_percentage':
                is_valid, message = InputValidator.validate_take_profit(value, user_id)
                if not is_valid:
                    logger.error(f"Invalid take profit update attempt: {value} for user {user_id} - {message}")
                    raise ValueError(f"Ge√ßersiz take profit: {message}")
        
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        # Dinamik g√ºncelleme
        fields = []
        values = []
        for key, value in settings.items():
            fields.append(f"{key} = ?")
            values.append(value)
        
        if fields:
            fields.append("updated_at = CURRENT_TIMESTAMP")
            values.append(user_id)
            
            cursor.execute(f'''
                UPDATE user_settings SET {', '.join(fields)} WHERE user_id = ?
            ''', values)
        
        conn.commit()
        conn.close()
        logger.info(f"User settings updated successfully for user {user_id}: {settings}")
    
    def get_user_settings(self, user_id: int) -> Dict:
        """Kullanƒ±cƒ± ayarlarƒ±nƒ± getir"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
            SELECT trading_amount_usdt, take_profit_percentage, auto_trading, 
                   notifications, emergency_stop
            FROM user_settings WHERE user_id = ?
        ''', (user_id,))
        
        result = cursor.fetchone()
        conn.close()
        
        if result:
            return {
                'trading_amount': result[0],
                'take_profit': result[1],
                'auto_trading': bool(result[2]),
                'notifications': bool(result[3]),
                'emergency_stop': bool(result[4])
            }
        
        # Varsayƒ±lan ayarlar
        return {
            'trading_amount': 20.0,
            'take_profit': 500.0,
            'auto_trading': True,
            'notifications': True,
            'emergency_stop': False
        }
    
    def add_trade_record(self, user_id: int, symbol: str, action: str, amount_usdt: float, 
                        price: float, status: str = 'OPEN') -> int:
        """ƒ∞≈ülem kaydƒ± ekle"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
            INSERT INTO trade_history 
            (user_id, symbol, action, amount_usdt, price, status)
            VALUES (?, ?, ?, ?, ?, ?)
        ''', (user_id, symbol, action, amount_usdt, price, status))
        
        trade_id = cursor.lastrowid
        conn.commit()
        conn.close()
        return trade_id
    
    def close_trade_record(self, trade_id: int, profit_loss: float):
        """ƒ∞≈ülem kaydƒ±nƒ± kapat"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
            UPDATE trade_history 
            SET status = 'CLOSED', profit_loss = ?, closed_at = CURRENT_TIMESTAMP
            WHERE id = ?
        ''', (profit_loss, trade_id))
        
        conn.commit()
        conn.close()
    
    def add_notification(self, user_id: int, notification_type: str, title: str, message: str):
        """Bildirim ekle"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
            INSERT INTO notifications (user_id, type, title, message)
            VALUES (?, ?, ?, ?)
        ''', (user_id, notification_type, title, message))
        
        conn.commit()
        conn.close()
    
    def get_active_users(self) -> List[int]:
        """Aktif kullanƒ±cƒ±larƒ± getir"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
            SELECT user_id FROM users WHERE is_active = 1
        ''')
        
        users = [row[0] for row in cursor.fetchall()]
        conn.close()
        return users

class AdvancedTradingBot:
    """Geli≈ümi≈ü Telegram ticaret botu"""
    
    def __init__(self):
        self.db = TradingBotDatabase()
        self.active_trades = {}  # user_id -> trade_info
        self.pending_api_setup = {}  # user_id -> setup_step
        self.BASE_DIR = os.getcwd()
        # Centralized notification configuration kullan
        self.notification_file = notification_config.telegram_notifications_file
        self.last_notification_check = 0
        print(f"ü§ñ Telegram Bot using centralized notification config: {self.notification_file}")
        
    async def start_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Bot ba≈ülatma komutu"""
        user = update.effective_user
        chat_id = update.effective_chat.id
        
        # Kullanƒ±cƒ±yƒ± kaydet
        self.db.register_user(
            user_id=user.id,
            username=user.username or "unknown",
            first_name=user.first_name,
            last_name=user.last_name
        )
        
        welcome_text = f"""
üöÄ **Kripto Ticaret Bot'a Ho≈ü Geldin, {user.first_name}!**

Bu bot ile:
‚Ä¢ üîë API anahtarlarƒ±nƒ± g√ºvenle y√∂net
‚Ä¢ üí∞ ƒ∞≈ülem miktarlarƒ±nƒ± ayarla
‚Ä¢ üìà Take Profit hedeflerini belirle
‚Ä¢ üö® Upbit yeni coin bildirimlerini al
‚Ä¢ ‚ö° Acil durdurma ile i≈ülemleri kontrol et

Ba≈ülamak i√ßin a≈üaƒüƒ±daki butonu kullan:
        """
        
        keyboard = [
            [InlineKeyboardButton("üéõÔ∏è Bot Ayarlarƒ±", callback_data="main_menu")],
            [InlineKeyboardButton("üìä ƒ∞≈ülem Durumu", callback_data="trade_status")],
            [InlineKeyboardButton("üÜò Yardƒ±m", callback_data="help")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await update.message.reply_text(
            welcome_text, 
            parse_mode=ParseMode.MARKDOWN,
            reply_markup=reply_markup
        )
    
    async def main_menu_callback(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Ana men√º callback'i"""
        query = update.callback_query
        await query.answer()
        
        user_id = query.from_user.id
        api_keys = self.db.get_user_api_keys(user_id)
        settings = self.db.get_user_settings(user_id)
        
        status_api = "‚úÖ Yapƒ±landƒ±rƒ±ldƒ±" if api_keys and api_keys['is_configured'] else "‚ùå Yapƒ±landƒ±rƒ±lmadƒ±"
        status_trading = "üü¢ Aktif" if settings['auto_trading'] else "üî¥ Pasif"
        
        menu_text = f"""
üéõÔ∏è **Bot Ayarlarƒ±**

üîë **API Durumu:** {status_api}
üí∞ **ƒ∞≈ülem Miktarƒ±:** {settings['trading_amount']} USDT
üìà **Take Profit:** %{settings['take_profit']}
ü§ñ **Otomatik Ticaret:** {status_trading}
üîî **Bildirimler:** {"A√ßƒ±k" if settings['notifications'] else "Kapalƒ±"}

Ayarlamak istediƒüin kƒ±smƒ± se√ß:
        """
        
        keyboard = [
            [InlineKeyboardButton("üîë API Anahtarlarƒ±", callback_data="setup_api")],
            [InlineKeyboardButton("üí∞ ƒ∞≈ülem Miktarƒ±", callback_data="set_amount")],
            [InlineKeyboardButton("üìà Take Profit", callback_data="set_tp")],
            [InlineKeyboardButton("ü§ñ Oto Ticaret", callback_data="toggle_auto")],
            [InlineKeyboardButton("üìä Manuel Long", callback_data="manual_long")],
            [InlineKeyboardButton("üîî Bildirimler", callback_data="toggle_notifications")],
            [InlineKeyboardButton("üö® ACƒ∞L DURDUR", callback_data="emergency_stop")],
            [InlineKeyboardButton("‚óÄÔ∏è Ana Men√º", callback_data="back_main")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await query.edit_message_text(
            menu_text,
            parse_mode=ParseMode.MARKDOWN,
            reply_markup=reply_markup
        )
    
    async def setup_api_callback(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """API kurulum callback'i"""
        query = update.callback_query
        await query.answer()
        
        user_id = query.from_user.id
        self.pending_api_setup[user_id] = {'step': 'api_key'}
        
        api_text = """
üîë **Bitget API Anahtarlarƒ± Kurulumu**

API anahtarlarƒ±nƒ± g√ºvenle eklemek i√ßin:

**1. Adƒ±m:** Bitget API Key
Bitget hesabƒ±ndan aldƒ±ƒüƒ±n API anahtarƒ±nƒ± g√∂nder.

‚ö†Ô∏è **G√ºvenlik:** Anahtarlarƒ±n ≈üifrelenerek saklanacak.
        """
        
        keyboard = [
            [InlineKeyboardButton("‚ùå ƒ∞ptal", callback_data="main_menu")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await query.edit_message_text(
            api_text,
            parse_mode=ParseMode.MARKDOWN,
            reply_markup=reply_markup
        )
    
    async def handle_api_setup(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """API kurulum s√ºrecini y√∂net"""
        user_id = update.effective_user.id
        message_text = update.message.text
        
        if user_id not in self.pending_api_setup:
            return
        
        setup_data = self.pending_api_setup[user_id]
        step = setup_data['step']
        
        if step == 'api_key':
            setup_data['api_key'] = message_text
            setup_data['step'] = 'secret_key'
            await update.message.reply_text(
                "‚úÖ API Key kaydedildi!\n\nüîê **2. Adƒ±m:** Secret Key\nBitget Secret Key'ini g√∂nder:"
            )
        
        elif step == 'secret_key':
            setup_data['secret_key'] = message_text
            setup_data['step'] = 'passphrase'
            await update.message.reply_text(
                "‚úÖ Secret Key kaydedildi!\n\nüîë **3. Adƒ±m:** Passphrase\nBitget Passphrase'ini g√∂nder:"
            )
        
        elif step == 'passphrase':
            setup_data['passphrase'] = message_text
            
            # API anahtarlarƒ±nƒ± kaydet
            self.db.save_api_keys(
                user_id=user_id,
                api_key=setup_data['api_key'],
                secret_key=setup_data['secret_key'],
                passphrase=setup_data['passphrase']
            )
            
            # Kurulum tamamlandƒ±
            del self.pending_api_setup[user_id]
            
            keyboard = [
                [InlineKeyboardButton("üéõÔ∏è Bot Ayarlarƒ±", callback_data="main_menu")],
                [InlineKeyboardButton("üöÄ Ticareti Ba≈ülat", callback_data="start_trading")]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)
            
            await update.message.reply_text(
                "üéâ **API Anahtarlarƒ± Ba≈üarƒ±yla Kaydedildi!**\n\n"
                "Artƒ±k otomatik ticaret yapabilirsin.\n"
                "Bot ayarlarƒ±na d√∂nmek i√ßin butonu kullan.",
                reply_markup=reply_markup
            )
            
            # Sistem environment variable'larƒ±nƒ± g√ºncelle (ge√ßici)
            await self.update_system_env_vars(user_id)
    
    async def update_system_env_vars(self, user_id: int):
        """Sistem environment variable'larƒ±nƒ± g√ºncelle"""
        api_keys = self.db.get_user_api_keys(user_id)
        if api_keys and api_keys['is_configured']:
            # Ana sistem i√ßin environment variable'larƒ± ayarla
            os.environ['BITGET_API_KEY'] = api_keys['api_key']
            os.environ['BITGET_SECRET_KEY'] = api_keys['secret_key']
            os.environ['BITGET_PASSPHRASE'] = api_keys['passphrase']
            
            print(f"üîë {user_id} kullanƒ±cƒ±sƒ± i√ßin API anahtarlarƒ± sisteme y√ºklendi")
    
    async def set_trading_amount_callback(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """ƒ∞≈ülem miktarƒ± ayarlama callback'i"""
        query = update.callback_query
        await query.answer()
        
        amount_text = """
üí∞ **ƒ∞≈ülem Miktarƒ± Ayarla**

Her i≈ülem i√ßin kullanƒ±lacak USDT miktarƒ±nƒ± se√ß:
        """
        
        keyboard = [
            [
                InlineKeyboardButton("10 USDT", callback_data="amount_10"),
                InlineKeyboardButton("20 USDT", callback_data="amount_20"),
                InlineKeyboardButton("50 USDT", callback_data="amount_50")
            ],
            [
                InlineKeyboardButton("100 USDT", callback_data="amount_100"),
                InlineKeyboardButton("200 USDT", callback_data="amount_200"),
                InlineKeyboardButton("500 USDT", callback_data="amount_500")
            ],
            [InlineKeyboardButton("‚óÄÔ∏è Geri", callback_data="main_menu")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await query.edit_message_text(
            amount_text,
            parse_mode=ParseMode.MARKDOWN,
            reply_markup=reply_markup
        )
    
    async def amount_selection_callback(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """ƒ∞≈ülem miktarƒ± se√ßimi callback'i - G√ºvenlik doƒürulamasƒ± ile"""
        query = update.callback_query
        await query.answer()
        
        user_id = query.from_user.id
        
        try:
            # Callback data'dan miktarƒ± √ßƒ±kar
            amount_str = query.data.split('_')[1]
            amount = float(amount_str)
            
            # G√ºvenlik doƒürulamasƒ±
            is_valid, message = InputValidator.validate_trading_amount(amount, user_id)
            if not is_valid:
                await query.edit_message_text(
                    f"‚ùå **G√ºvenlik Hatasƒ±:**\n{message}\n\n"
                    "L√ºtfen ge√ßerli bir miktar se√ßin.",
                    parse_mode=ParseMode.MARKDOWN,
                    reply_markup=InlineKeyboardMarkup([
                        [InlineKeyboardButton("üîÑ Tekrar Dene", callback_data="set_amount")],
                        [InlineKeyboardButton("üéõÔ∏è Bot Ayarlarƒ±", callback_data="main_menu")]
                    ])
                )
                return
            
            # Ayarlarƒ± g√ºncelle
            self.db.update_user_settings(user_id, trading_amount_usdt=amount)
            
            await query.edit_message_text(
                f"‚úÖ **ƒ∞≈ülem miktarƒ± {amount} USDT olarak ayarlandƒ±!**\n\n"
                "Artƒ±k her i≈ülemde bu miktar kullanƒ±lacak.\n"
                f"üõ°Ô∏è G√ºvenlik: Onaylanmƒ±≈ü miktar kullanƒ±lƒ±yor.",
                parse_mode=ParseMode.MARKDOWN,
                reply_markup=InlineKeyboardMarkup([
                    [InlineKeyboardButton("üéõÔ∏è Bot Ayarlarƒ±", callback_data="main_menu")]
                ])
            )
            
        except (ValueError, IndexError) as e:
            logger.error(f"Amount selection error for user {user_id}: {e}")
            await query.edit_message_text(
                "‚ùå **Miktar se√ßimi hatasƒ±!**\n\n"
                "L√ºtfen ge√ßerli bir miktar se√ßin.",
                parse_mode=ParseMode.MARKDOWN,
                reply_markup=InlineKeyboardMarkup([
                    [InlineKeyboardButton("üîÑ Tekrar Dene", callback_data="set_amount")],
                    [InlineKeyboardButton("üéõÔ∏è Bot Ayarlarƒ±", callback_data="main_menu")]
                ])
            )
    
    async def set_take_profit_callback(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Take Profit ayarlama callback'i"""
        query = update.callback_query
        await query.answer()
        
        tp_text = """
üìà **Take Profit Hedefi Ayarla**

ƒ∞≈ülemlerin otomatik kapatƒ±lmasƒ± i√ßin kar hedefini se√ß:
        """
        
        keyboard = [
            [
                InlineKeyboardButton("200%", callback_data="tp_200"),
                InlineKeyboardButton("300%", callback_data="tp_300"),
                InlineKeyboardButton("500%", callback_data="tp_500")
            ],
            [
                InlineKeyboardButton("600%", callback_data="tp_600"),
                InlineKeyboardButton("800%", callback_data="tp_800"),
                InlineKeyboardButton("1000%", callback_data="tp_1000")
            ],
            [InlineKeyboardButton("‚óÄÔ∏è Geri", callback_data="main_menu")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await query.edit_message_text(
            tp_text,
            parse_mode=ParseMode.MARKDOWN,
            reply_markup=reply_markup
        )
    
    async def tp_selection_callback(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Take Profit se√ßimi callback'i - G√ºvenlik doƒürulamasƒ± ile"""
        query = update.callback_query
        await query.answer()
        
        user_id = query.from_user.id
        
        try:
            # Callback data'dan y√ºzdeyi √ßƒ±kar
            tp_str = query.data.split('_')[1]
            tp_percentage = float(tp_str)
            
            # G√ºvenlik doƒürulamasƒ±
            is_valid, message = InputValidator.validate_take_profit(tp_percentage, user_id)
            if not is_valid:
                await query.edit_message_text(
                    f"‚ùå **G√ºvenlik Hatasƒ±:**\n{message}\n\n"
                    "L√ºtfen ge√ßerli bir y√ºzde se√ßin.",
                    parse_mode=ParseMode.MARKDOWN,
                    reply_markup=InlineKeyboardMarkup([
                        [InlineKeyboardButton("üîÑ Tekrar Dene", callback_data="set_tp")],
                        [InlineKeyboardButton("üéõÔ∏è Bot Ayarlarƒ±", callback_data="main_menu")]
                    ])
                )
                return
            
            # Ayarlarƒ± g√ºncelle
            self.db.update_user_settings(user_id, take_profit_percentage=tp_percentage)
            
            await query.edit_message_text(
                f"‚úÖ **Take Profit %{tp_percentage} olarak ayarlandƒ±!**\n\n"
                f"ƒ∞≈ülemler %{tp_percentage} k√¢ra ula≈ütƒ±ƒüƒ±nda otomatik kapatƒ±lacak.\n"
                f"üõ°Ô∏è G√ºvenlik: Onaylanmƒ±≈ü y√ºzde kullanƒ±lƒ±yor.",
                parse_mode=ParseMode.MARKDOWN,
                reply_markup=InlineKeyboardMarkup([
                    [InlineKeyboardButton("üéõÔ∏è Bot Ayarlarƒ±", callback_data="main_menu")]
                ])
            )
            
        except (ValueError, IndexError) as e:
            logger.error(f"Take profit selection error for user {user_id}: {e}")
            await query.edit_message_text(
                "‚ùå **Take Profit se√ßimi hatasƒ±!**\n\n"
                "L√ºtfen ge√ßerli bir y√ºzde se√ßin.",
                parse_mode=ParseMode.MARKDOWN,
                reply_markup=InlineKeyboardMarkup([
                    [InlineKeyboardButton("üîÑ Tekrar Dene", callback_data="set_tp")],
                    [InlineKeyboardButton("üéõÔ∏è Bot Ayarlarƒ±", callback_data="main_menu")]
                ])
            )
    
    async def emergency_stop_callback(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Acil durdurma callback'i"""
        query = update.callback_query
        await query.answer()
        
        user_id = query.from_user.id
        
        confirm_text = """
üö® **ACƒ∞L DURDURMA**

‚ö†Ô∏è **Dƒ∞KKAT:** Bu i≈ülem:
‚Ä¢ T√ºm a√ßƒ±k pozisyonlarƒ± kapatacak
‚Ä¢ Otomatik ticareti durduracak
‚Ä¢ Kayƒ±pla sonu√ßlanabilir

Emin misin?
        """
        
        keyboard = [
            [
                InlineKeyboardButton("‚úÖ EVET, DURDUR", callback_data="confirm_emergency"),
                InlineKeyboardButton("‚ùå HAYIR", callback_data="main_menu")
            ]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await query.edit_message_text(
            confirm_text,
            parse_mode=ParseMode.MARKDOWN,
            reply_markup=reply_markup
        )
    
    async def confirm_emergency_stop(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Acil durdurma onayƒ±"""
        query = update.callback_query
        await query.answer()
        
        user_id = query.from_user.id
        
        # Kullanƒ±cƒ± ayarlarƒ±nƒ± g√ºncelle
        self.db.update_user_settings(
            user_id, 
            auto_trading=False, 
            emergency_stop=True
        )
        
        # Kullanƒ±cƒ±nƒ±n API anahtarlarƒ±nƒ± al
        api_keys = self.db.get_user_api_keys(user_id)
        
        if api_keys and api_keys['is_configured']:
            # Kullanƒ±cƒ± bazlƒ± emergency stop dosyasƒ± olu≈ütur
            user_dir = os.path.join(os.path.dirname(__file__), "PERP", "users", str(user_id))
            os.makedirs(user_dir, exist_ok=True)
            emergency_file = os.path.join(user_dir, "emergency_stop.txt")
            
            with open(emergency_file, 'w') as f:
                f.write("EMERGENCY_STOP")
            
            # Kullanƒ±cƒ± bazlƒ± environment ile pozisyon kapatma scriptini √ßalƒ±≈ütƒ±r
            try:
                user_env = os.environ.copy()
                user_env['BITGET_API_KEY'] = api_keys['api_key']
                user_env['BITGET_SECRET_KEY'] = api_keys['secret_key'] 
                user_env['BITGET_PASSPHRASE'] = api_keys['passphrase']
                user_env['USER_ID'] = str(user_id)
                
                result = subprocess.run(
                    ["python3", "PERP/kapat.py"],
                    capture_output=True,
                    text=True,
                    timeout=30,
                    env=user_env
                )
                print(f"Acil durdurma sonucu (User {user_id}): {result.returncode}")
            except Exception as e:
                print(f"Acil durdurma hatasƒ± (User {user_id}): {e}")
        else:
            print(f"User {user_id} i√ßin API anahtarlarƒ± bulunamadƒ±")
        
        await query.edit_message_text(
            "üö® **ACƒ∞L DURDURMA TAMAMLANDI**\n\n"
            "‚Ä¢ T√ºm pozisyonlar kapatƒ±ldƒ±\n"
            "‚Ä¢ Otomatik ticaret durduruldu\n"
            "‚Ä¢ Sistem g√ºvenlik modunda\n\n"
            "Yeniden ba≈ülatmak i√ßin bot ayarlarƒ±na git.",
            parse_mode=ParseMode.MARKDOWN,
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("üéõÔ∏è Bot Ayarlarƒ±", callback_data="main_menu")]
            ])
        )
        
        # Bildirim ekle
        self.db.add_notification(
            user_id, 
            'SYSTEM', 
            'Acil Durdurma', 
            'T√ºm pozisyonlar kapatƒ±ldƒ± ve sistem durduruldu.'
        )
    
    async def broadcast_new_coin_notification(self, coin_symbol: str, coin_name: str, price: float):
        """Yeni coin bildirimini t√ºm kullanƒ±cƒ±lara g√∂nder"""
        active_users = self.db.get_active_users()
        
        notification_text = f"""
üö® **YENƒ∞ COƒ∞N Lƒ∞STELENDƒ∞!**

üí∞ **Coin:** {coin_name} ({coin_symbol})
üíµ **Fiyat:** ${price}
üìà **Durum:** ƒ∞≈ülem a√ßƒ±lƒ±yor...

Otomatik ticaret ayarlarƒ±n aktifse i≈ülem ba≈ülatƒ±lacak.
        """
        
        keyboard = [
            [InlineKeyboardButton("üìä ƒ∞≈ülem Detaylarƒ±", callback_data=f"trade_details_{coin_symbol}")],
            [InlineKeyboardButton("üö® ACƒ∞L DURDUR", callback_data="emergency_stop")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        # Telegram application instance gerekli (ana sistemle entegrasyon gerekir)
        for user_id in active_users:
            try:
                # Bu kƒ±sƒ±m ana sistemle entegre edilecek
                self.db.add_notification(
                    user_id, 
                    'NEW_COIN', 
                    f'Yeni Coin: {coin_symbol}', 
                    f'{coin_name} ({coin_symbol}) ${price} fiyatƒ±yla listelendi.'
                )
                print(f"üì¢ {user_id} kullanƒ±cƒ±sƒ±na yeni coin bildirimi g√∂nderildi: {coin_symbol}")
            except Exception as e:
                print(f"Bildirim g√∂nderme hatasƒ± (User {user_id}): {e}")
    
    async def manual_long_callback(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Manuel long i≈ülemi callback'i"""
        query = update.callback_query
        await query.answer()
        
        user_id = query.from_user.id
        api_keys = self.db.get_user_api_keys(user_id)
        settings = self.db.get_user_settings(user_id)
        
        # API anahtarlarƒ± kontrol√º
        if not api_keys or not api_keys['is_configured']:
            await query.edit_message_text(
                "‚ùå **API Anahtarlarƒ± Eksik!**\n\n"
                "Manuel i≈ülem yapmak i√ßin √∂nce Bitget API anahtarlarƒ±nƒ± eklemen gerekiyor.\n\n"
                "üîë Bot Ayarlarƒ± ‚Üí API Anahtarlarƒ±",
                parse_mode=ParseMode.MARKDOWN,
                reply_markup=InlineKeyboardMarkup([
                    [InlineKeyboardButton("üîë API Ekle", callback_data="setup_api")],
                    [InlineKeyboardButton("‚óÄÔ∏è Geri", callback_data="main_menu")]
                ])
            )
            return
        
        # Pop√ºler coin listesi
        popular_coins = [
            "BTC", "ETH", "BNB", "SOL", "ADA", "XRP", "DOT", "MATIC", 
            "LINK", "AVAX", "LTC", "BCH", "UNI", "ATOM", "FTM", "NEAR"
        ]
        
        manual_text = f"""
üìä **Manuel Long ƒ∞≈ülemi**

üéØ **Mevcut Ayarlarƒ±n:**
üí∞ ƒ∞≈ülem Miktarƒ±: {settings['trading_amount']} USDT
üìà Take Profit: %{settings['take_profit']}
‚ö° Leverage: Maksimum (Bitget otomatik)

ü™ô **Coin Se√ßimi:**
A≈üaƒüƒ±daki pop√ºler coinlerden birini se√ß.
        """
        
        # Pop√ºler coinleri 4'l√º satƒ±rlarda d√ºzenle
        keyboard = []
        for i in range(0, len(popular_coins), 4):
            row = []
            for j in range(i, min(i + 4, len(popular_coins))):
                coin = popular_coins[j]
                row.append(InlineKeyboardButton(f"{coin}", callback_data=f"long_{coin}"))
            keyboard.append(row)
        
        # Alt butonlar
        keyboard.append([InlineKeyboardButton("‚óÄÔ∏è Geri", callback_data="main_menu")])
        
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await query.edit_message_text(
            manual_text,
            parse_mode=ParseMode.MARKDOWN,
            reply_markup=reply_markup
        )
    
    async def manual_long_selection_callback(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Manuel long coin se√ßimi callback'i"""
        query = update.callback_query
        await query.answer()
        
        user_id = query.from_user.id
        coin_symbol = query.data.replace("long_", "")
        settings = self.db.get_user_settings(user_id)
        
        # Onay mesajƒ±
        confirm_text = f"""
üöÄ **Long ƒ∞≈ülemi Onayƒ±**

ü™ô **Coin:** {coin_symbol}USDT_UMCBL
üí∞ **Miktar:** {settings['trading_amount']} USDT
üìà **Take Profit:** %{settings['take_profit']}
‚ö° **Leverage:** Maksimum
üéØ **ƒ∞≈ülem T√ºr√º:** Long (Y√ºkseli≈ü bahsi)

‚ö†Ô∏è **Dƒ∞KKAT:** Bu ger√ßek para ile i≈ülem a√ßacak!

Bu ayarlarla long i≈ülemi a√ßmak istediƒüinden emin misin?
        """
        
        keyboard = [
            [
                InlineKeyboardButton("‚úÖ EVET, A√á", callback_data=f"confirm_long_{coin_symbol}"),
                InlineKeyboardButton("‚ùå HAYIR", callback_data="manual_long")
            ]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await query.edit_message_text(
            confirm_text,
            parse_mode=ParseMode.MARKDOWN,
            reply_markup=reply_markup
        )
    
    async def confirm_manual_long_callback(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Manuel long i≈ülemini onayla ve ger√ßekle≈ütir"""
        query = update.callback_query
        await query.answer()
        
        user_id = query.from_user.id
        coin_symbol = query.data.replace("confirm_long_", "")
        settings = self.db.get_user_settings(user_id)
        
        try:
            # Kullanƒ±cƒ± bazlƒ± dizin olu≈ütur
            user_dir = os.path.join(os.path.dirname(__file__), "PERP", "users", str(user_id))
            os.makedirs(user_dir, exist_ok=True)
            
            # Manuel long i≈ülemi dosyasƒ±nƒ± kullanƒ±cƒ± bazlƒ± olu≈ütur
            perp_symbol = f"{coin_symbol}USDT_UMCBL"
            perp_file = os.path.join(user_dir, "manual_long_output.txt")
            
            with open(perp_file, 'w') as f:
                f.write(perp_symbol)
            
            # Log kaydƒ± olu≈ütur
            logger.info(f"Manual long triggered: {coin_symbol} by user {user_id}")
            
            # Bildirim mesajƒ±
            await query.edit_message_text(
                f"üöÄ **Manuel Long ƒ∞≈ülemi Tetiklendi!**\n\n"
                f"ü™ô **Coin:** {coin_symbol}\n"
                f"üí∞ **Miktar:** {settings['trading_amount']} USDT\n"
                f"üìà **Take Profit:** %{settings['take_profit']}\n"
                f"‚ö° **Format:** {perp_symbol}\n\n"
                f"üîÑ ƒ∞≈ülem Bitget'te a√ßƒ±lƒ±yor...\n"
                f"üì± Sonu√ß bildirimi gelecek!\n\n"
                f"‚ö†Ô∏è Pozisyon durumunu takip edin.",
                parse_mode=ParseMode.MARKDOWN,
                reply_markup=InlineKeyboardMarkup([
                    [InlineKeyboardButton("üìä ƒ∞≈ülem Durumu", callback_data="trade_status")],
                    [InlineKeyboardButton("üö® ACƒ∞L DURDUR", callback_data="emergency_stop")],
                    [InlineKeyboardButton("üéõÔ∏è Bot Ayarlarƒ±", callback_data="main_menu")]
                ])
            )
            
            # Veritabanƒ±na bildirim ekle
            self.db.add_notification(
                user_id, 
                'MANUAL_LONG', 
                f'Manuel Long: {coin_symbol}', 
                f'{coin_symbol} i√ßin manuel long i≈ülemi tetiklendi ({settings["trading_amount"]} USDT)'
            )
            
        except Exception as e:
            logger.error(f"Manual long error for user {user_id}: {e}")
            await query.edit_message_text(
                f"‚ùå **Manuel Long Hatasƒ±!**\n\n"
                f"Hata: {str(e)}\n\n"
                f"L√ºtfen tekrar deneyin.",
                parse_mode=ParseMode.MARKDOWN,
                reply_markup=InlineKeyboardMarkup([
                    [InlineKeyboardButton("üîÑ Tekrar Dene", callback_data="manual_long")],
                    [InlineKeyboardButton("üéõÔ∏è Bot Ayarlarƒ±", callback_data="main_menu")]
                ])
            )
    
    async def broadcast_trade_notification(self, user_id: int, action: str, coin_symbol: str, 
                                         amount: float, price: float, trade_id: int):
        """ƒ∞≈ülem bildirimini kullanƒ±cƒ±ya g√∂nder"""
        
        action_text = "üìà A√áILDI" if action == "BUY" else "üìâ KAPATILDI"
        
        trade_text = f"""
{action_text} **ƒ∞≈ûLEM Bƒ∞LDƒ∞Rƒ∞Mƒ∞**

üí∞ **Coin:** {coin_symbol}
üíµ **Miktar:** {amount} USDT
üí≤ **Fiyat:** ${price}
üïê **Zaman:** {datetime.now().strftime('%H:%M:%S')}

ƒ∞D: {trade_id}
        """
        
        keyboard = [
            [InlineKeyboardButton("üö® ACƒ∞L KAPAT", callback_data=f"emergency_close_{trade_id}")],
            [InlineKeyboardButton("üìä Detaylar", callback_data=f"trade_details_{trade_id}")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        # Bildirim ekle
        self.db.add_notification(
            user_id, 
            'TRADE_OPEN' if action == 'BUY' else 'TRADE_CLOSED', 
            f'ƒ∞≈ülem {action_text}', 
            f'{coin_symbol} i√ßin {amount} USDT i≈ülem {action_text.lower()}'
        )
        
        print(f"üì± {user_id} kullanƒ±cƒ±sƒ±na i≈ülem bildirimi: {action} {coin_symbol}")
    
    async def check_notification_file(self, application):
        """Bildirim dosyasƒ±nƒ± kontrol et ve Telegram bildirimlerini g√∂nder"""
        try:
            if not os.path.exists(self.notification_file):
                return
            
            # Dosya deƒüi≈üiklik zamanƒ±nƒ± kontrol et
            file_mtime = os.path.getmtime(self.notification_file)
            if file_mtime <= self.last_notification_check:
                return
            
            # Notification dosyasƒ±nƒ± oku
            with open(self.notification_file, 'r', encoding='utf-8') as f:
                notification_data = json.load(f)
            
            if notification_data.get('type') == 'NEW_COIN':
                coins = notification_data.get('coins', [])
                timestamp = notification_data.get('timestamp', '')
                
                # T√ºm aktif kullanƒ±cƒ±lara bildirim g√∂nder
                active_users = self.db.get_active_users()
                
                for coin in coins:
                    symbol = coin.get('symbol', '')
                    name = coin.get('name', '')
                    perp_symbol = coin.get('perp_symbol', '')
                    
                    notification_text = f"""
üö® **YENƒ∞ COƒ∞N Lƒ∞STELENDƒ∞!**

üí∞ **Coin:** {symbol}
üìù **Duyuru:** {name}
üîó **PERP Sembol:** {perp_symbol}
üïê **Zaman:** {datetime.now().strftime('%H:%M:%S')}

Otomatik ticaret ayarlarƒ±n aktifse i≈ülem ba≈ülatƒ±lacak.
                    """
                    
                    keyboard = [
                        [InlineKeyboardButton("üìä ƒ∞≈ülem Durumu", callback_data="trade_status")],
                        [InlineKeyboardButton("üö® ACƒ∞L DURDUR", callback_data="emergency_stop")]
                    ]
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    
                    # Her kullanƒ±cƒ±ya g√∂nder
                    for user_id in active_users:
                        try:
                            user_settings = self.db.get_user_settings(user_id)
                            if user_settings.get('notifications', True):
                                await application.bot.send_message(
                                    chat_id=user_id,
                                    text=notification_text,
                                    parse_mode=ParseMode.MARKDOWN,
                                    reply_markup=reply_markup
                                )
                                
                                # Veritabanƒ±na bildirim ekle
                                self.db.add_notification(
                                    user_id,
                                    'NEW_COIN',
                                    f'Yeni Coin: {symbol}',
                                    f'{symbol} listesine eklendi: {perp_symbol}'
                                )
                                
                                print(f"üì¢ {user_id} kullanƒ±cƒ±sƒ±na yeni coin bildirimi g√∂nderildi: {symbol}")
                        except Exception as e:
                            print(f"Bildirim g√∂nderme hatasƒ± (User {user_id}): {e}")
            
            # Son kontrol zamanƒ±nƒ± g√ºncelle
            self.last_notification_check = file_mtime
            
            # Bildirim dosyasƒ±nƒ± sil (tekrar i≈ülenmesini √∂nlemek i√ßin)
            try:
                os.remove(self.notification_file)
                print(f"üóëÔ∏è Bildirim dosyasƒ± i≈ülendikten sonra silindi")
            except:
                pass
                
        except Exception as e:
            print(f"‚ö†Ô∏è Bildirim kontrol hatasƒ±: {e}")

# Bot callback handler'larƒ±
async def callback_router(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Callback query'leri y√∂nlendir"""
    query = update.callback_query
    data = query.data
    
    bot_instance = context.bot_data.get('trading_bot')
    if not bot_instance:
        await query.answer("Bot instance bulunamadƒ±!")
        return
    
    # Callback routing
    if data == "main_menu":
        await bot_instance.main_menu_callback(update, context)
    elif data == "setup_api":
        await bot_instance.setup_api_callback(update, context)
    elif data == "set_amount":
        await bot_instance.set_trading_amount_callback(update, context)
    elif data.startswith("amount_"):
        await bot_instance.amount_selection_callback(update, context)
    elif data == "set_tp":
        await bot_instance.set_take_profit_callback(update, context)
    elif data.startswith("tp_"):
        await bot_instance.tp_selection_callback(update, context)
    elif data == "emergency_stop":
        await bot_instance.emergency_stop_callback(update, context)
    elif data == "confirm_emergency":
        await bot_instance.confirm_emergency_stop(update, context)
    elif data == "manual_long":
        await bot_instance.manual_long_callback(update, context)
    elif data.startswith("long_"):
        await bot_instance.manual_long_selection_callback(update, context)
    elif data.startswith("confirm_long_"):
        await bot_instance.confirm_manual_long_callback(update, context)
    else:
        await query.answer("Bu √∂zellik hen√ºz hazƒ±r deƒüil!")

# Periyodik g√∂revler i√ßin job scheduler
async def periodic_notification_check(context: ContextTypes.DEFAULT_TYPE):
    """Periyodik olarak bildirim dosyasƒ±nƒ± kontrol et"""
    trading_bot = context.bot_data.get('trading_bot')
    if trading_bot:
        await trading_bot.check_notification_file(context.application)

# Ana bot fonksiyonu
def main():
    """Telegram bot'u ba≈ülat"""
    
    # Bot token kontrol√º
    BOT_TOKEN = os.getenv('TELEGRAM_BOT_TOKEN')
    if not BOT_TOKEN:
        print("‚ùå TELEGRAM_BOT_TOKEN environment variable tanƒ±mlanmamƒ±≈ü!")
        print("‚ö†Ô∏è Bot token'ƒ±nƒ± environment variable olarak ekleyin.")
        print("‚ÑπÔ∏è Bot bildirim sistemi pasif modda √ßalƒ±≈üacak...")
        
        # Token olmadan √ßalƒ±≈üabilir ama bildirim g√∂nderemez
        while True:
            try:
                time.sleep(60)
                print("üí§ TELEGRAM_BOT_TOKEN bekleniyor...")
            except KeyboardInterrupt:
                print("\nüëã Bot durduruldu")
                break
        return
    
    # Bot instance olu≈ütur
    trading_bot = AdvancedTradingBot()
    
    # Application olu≈ütur
    application = Application.builder().token(BOT_TOKEN).build()
    
    # Bot instance'ƒ± context'e ekle
    application.bot_data['trading_bot'] = trading_bot
    
    # Komut handler'larƒ±nƒ± ekle
    application.add_handler(CommandHandler("start", trading_bot.start_command))
    application.add_handler(CallbackQueryHandler(callback_router))
    
    # API kurulum mesajlarƒ±nƒ± yakala
    application.add_handler(MessageHandler(
        filters.TEXT & ~filters.COMMAND, 
        trading_bot.handle_api_setup
    ))
    
    # Periyodik g√∂revler (Job Queue)
    job_queue = application.job_queue
    job_queue.run_repeating(
        periodic_notification_check, 
        interval=30,  # 30 saniyede bir kontrol
        first=10      # ƒ∞lk kontrol 10 saniye sonra
    )
    
    print("ü§ñ Geli≈ümi≈ü Telegram Bot ba≈ülatƒ±lƒ±yor...")
    print("üîÑ Kullanƒ±cƒ± y√∂netimi aktif")
    print("üóÑÔ∏è Veritabanƒ± baƒülantƒ±sƒ± hazƒ±r")
    print("üì± Bildirim sistemi aktif (30 saniyede bir kontrol)")
    
    # Bot'u √ßalƒ±≈ütƒ±r
    application.run_polling()

if __name__ == '__main__':
    main()